# Importing relevant libraries.
import sys
from datetime import datetime
"""
This program allows users to login into the application. Once the user
has login he/she will be prompted to choose what he/she intends to do.
Admin users menu options:
- To register a new user.
- Add a task.
- View all tasks.
- View my tasks.
- Generate tasks report.
- Generate user report.
- Display statistics.
- Exit the system.
Non-admin usesr options:
- View my tasks.
- View all tasks.
- Add a task.
- Exit the system

This program contains mini functions that performs a particular function of the program.
The program has the following functions:
1. read_user_file: Reads and return usernames and passwords
2. login: Handles the login process for users
3. register_user: Registers new users
add_task: Adds a task to the assigned user
4. view_all: Read tasks.txt file and returns a dictionary with task numbers as keys,
and task details as values. The function also displays all tasks in the system.
5. view_mine: Reads tasks.txt file and returns a dictionary with tasks numbers as keys,
and task details as values. The function also displays task details of the logged in user.
6. task_report: Generates tasks summary statistics and writes them in a task_overview.txt file.
7. username_overview: Generates tasks summary statistics for each user and writes them 
in username_overview.txt file.
8. display_stats: Displays the summary statistics generated by the task_overview.txt file, and
username_overview.txt dile.
10. edit: Prompts user input to mark or edit the content of the tasks file.
11. update_task_file: After captures the updated information from the edit function, and
writes the information on the tasks.txt file.
12. main_menu: Contains the login of the task management system. It executes as per menu options.
"""
# Function to open and read the user.txt file.
def read_user_file(filename):
    """
    Reads the usernames and passwords from the file.
    
    The function performs the following:
    - It reads the usernames and passwords from username.txt. Usernames are stored
    in the valid_username list and passwords are stored in the valid_passwords list.
    
    Returns:
    - Returns valid_usernames and valid_passwords
    """
    valid_usernames = []  # Empty list to store all registered usernames.
    valid_passwords = []  # Empty list to store all registered passwords.

    # Reading user file.
    with open(filename, "r") as file:
        users = file.readlines()

    # Extract usernames and passwords.
    for line in users:
        # The following code reads usernames and their associated passwords
        # From the user.txt and appends them in the relevant empty list.
        username_and_password = line.strip().split(', ')
        valid_usernames.append(username_and_password[0])
        valid_passwords.append(username_and_password[1])

    return valid_usernames, valid_passwords

# Function to login
def login(valid_usernames, valid_passwords):
    '''
    Handles the login process for users. If the username and password
    match, the user logs in successfully. Three login attempts are allowed.
    '''
    """
    Handles the login process for users. If the username and password matches, the user
    logs in successfully. Three login attempts are allowed

    This function performs the following:
    - Prompts the user to enter a username and checks if it exists in the list of 
    valid usernames.
    - If the username is invalid, the user is prompted again until to a maximum of three attempts.
    - After a valid username, the user is prompted to enter a password and confirm it.
    - The user is only allowed a maximum of three attempts in password entry.

    Arguments:
    - Valid_usernames: A list of valid usernames that can be used to login.
    - Valid_password: A list of corresponding passwords. Each password
    is indexed to match the associated username.

    Returns:
    - Returns the username that successfully logged in.
    """
    max_attempt = 0  # Variable to track incorrect input.
    username = input("Please enter your username: ").lower()  # Prompts user input.

    # Loop to validate usernames.
    while username not in valid_usernames:
        username = input("Username not found. Please enter a valid username: ").lower()
        max_attempt += 1
        if max_attempt == 3:
            sys.exit("You have reached your maximum tries, please try again later.")

    password = input("Please enter your password: ")  # Prompts user input.

    # Loop to validate a username's password.
    # Ensures only a username with its associated password can login.
    while password != valid_passwords[valid_usernames.index(username)]:
        password = input("Incorrect password. Please enter your password again: ")
        max_attempt += 1
        if max_attempt == 3:
            sys.exit("You have reached your maximum tries, please try again later.")

    return username

# Function to register a new user (admin only).
def register_user():
    """
    This function registers a user and it is only accessable to Admin
    users.
    
    This function performs the following:
    - Prompts the user to enter a username of the person being registered.
    - If the new username matches with any username on valid_username lists,
    the username is rejected and the user is prompted to enter another username. The
    user will only allowed 3 maximum attempts
    - The user will be prompted enter and confirm a new user's password.
    - The user is allowed a maximum of three attempts if the passwords don't match.
    """
    max_attempt = 0  # Variable to track incorrect user inputs.

    # Prompts the user to register a new user.
    new_username = input("Please enter a new user's username: ").lower()

    # This code ensures that there are no duplicates in usernames registered.
    while new_username in valid_usernames:
        new_username = input("Username already exists. Please choose another: ")
        max_attempt += 1
        if max_attempt == 3:
            sys.exit("You have reached your maximum tries. Please try again later")

    new_password = input("Please enter a new password: ")  # Prompts user input.
    confirm_password = input("Please confirm the password: ")  # Prompts user input.

    # Validates the new user's password and writes them in a user.txt file.
    if new_password == confirm_password:
        with open("user.txt", "a") as file:
            file.write(f"\n{new_username}, {new_password}")
    else:
        print("Passwords did not match. Registration failed.")
        max_attempt += 1
        if max_attempt == 3:
            sys.exit("You have reached your maximum tries. Please try again later")

# Function to add a task.
def add_task():
    """
    Collects task information from the user and writes it to tasks.txt

    This function performs the following:
    - Prompts the user for input regarding tasjs details, including:
    The username of the person to whom the task is assigned.
    The title of the task.
    A description of the task.
    The due date for the task in the format (DD MM YYYY: 10 Jan 2019)
    - Automatically adds the current date when the task is created.
    - Marks the task as incomplete by default ('No').
    - Stores the collected task information in list called, tasks_to_add.
    - Lastly the writes the tasks_to_add list to a file
    """
    tasks_to_add = []  # Empty list to store all task information.

    # Prompts user input and stores data in tasks_to_add variable.
    username_assigned = input("Please enter the username of the person the task is assigned to: ")
    tasks_to_add.append(username_assigned)

    # Prompts user input and stores data in tasks_to_add variable.
    title_task = input("Please enter the title of the task: ")
    tasks_to_add.append(title_task)

    # Prompts user input and stores data in tasks_to_add variable.
    description_task = input("Please provide the description of the task: ")
    tasks_to_add.append(description_task)

    # Prompts user input and stores data in tasks_to_add variable.
    due_date = input("Please enter the due date for the task (format DD MM YYYY): ")
    tasks_to_add.append(due_date)

    # Adds today's date and stores data in tasks_to_add variable.
    date_of_task = datetime.now().strftime("%d %b %Y")
    tasks_to_add.append(date_of_task)

    # Stores data in tasks_to_add variable.
    task_completion = "No"
    tasks_to_add.append(task_completion)

    # Writes the information from the tasks_to_add varaible into a text file.
    tasks = open("tasks.txt", "a")
    tasks.write(f"\n{tasks_to_add[0]}")
    tasks.write(f", {tasks_to_add[1]}")
    tasks.write(f", {tasks_to_add[2]}")
    tasks.write(f", {tasks_to_add[3]}")
    tasks.write(f", {tasks_to_add[4]}")
    tasks.write(f", {tasks_to_add[5]}")
    tasks.close()
 
# Function to view all tasks.
def view_all():
    """
    Read tasks from tasks.txt and displays them in a readable format.

    The function performs the following:
    - Opens and reads the tasks.txt file line by line.
    - Each task is assigned a unique number starting from 1.
    - A dictionary is created for each task containing task details.
    - All tasks are stored in a main dictionary, where the keys are the 
    task numbers (1 to n) and the values are the task details.

    Returns:
    Returns a dictionary where each key is a task number, and each value is a
    dictionaty containing tasks details.
    """
    with open("tasks.txt", "r") as file:
        lines = file.readlines()

    all_tasks = {}  # Empty dictionary to add task information.

    # Loop through each line in the list 'lines', using enumerate to get the
    # line number starting at 1.
    for count, line in enumerate(lines, 1): 
        task_details = line.strip().split(", ")

        # Creates a dictionary to store task details with
        # appropriate keys and values from the split line.
        task_info = {
            "Task": task_details[1],             # Task description.
            "Assigned to": task_details[0],      # User assigned to the task.
            "Description": task_details[2],      # Additional details about the task.
            "Due date": task_details[3],         # Task due date.
            "Date assigned": task_details[4],    # Date the task was assigned.
            "Task complete?": task_details[5]    # Whether the task is marked complete.
        }
       # Store the dictionary in 'all_tasks' with the count (task number) as the key.
        all_tasks[count] = task_info

    return all_tasks  # Returns a numbered dictionary.

# Function to view tasks assigned to the currently logged-in user.
def view_mine(username):
    """
    Read tasks from tasks.txt and displays them in a readable format.

    The function performs the following:
    - Opens and reads the tasks.txt file line by line.
    - Each task is assigned a unique number starting from 1.
    - A dictionary is created for each task containing task details.
    - All tasks are stored in a main dictionary, where the keys are the 
    task numbers (1 to n) and the values are the task details.

    Returns:
    Returns a dictionary where each key is a task number, and each value is a
    dictionaty containing tasks details.
    """
    with open("tasks.txt", "r") as file:
        lines = file.readlines()

    my_tasks = {}  # Empty dictionary to add task information.

    # Loop through each line in the list 'lines', using enumerate to get the
    # line number starting at 1.
    for count, line in enumerate(lines, 1):
        task_details = line.strip().split(", ")

        if username == task_details[0]:
            task_info = {
                "Task": task_details[1],           # Task description.
                "Assigned to": task_details[0],    # User assigned to the task.
                "Description": task_details[2],    # Additional details about the task.
                "Due date": task_details[3],       # Task due date.
                "Date assigned": task_details[4],  # Date the task was assigned.
                "Task complete?": task_details[5]  # Whether the task is marked complete.
            }

             # Store the dictionary in 'all_tasks' with the count (task number) as the key.
            my_tasks[count] = task_info

    return my_tasks

# Function to generate a task report.
def task_report():
    """
    Generates a report on all tasks and writes it to tasks_overview.txt

    This function performs the following steps:
    1. Fetches all tasks using the view_all() function, which reads tasks from tasks.txt
    2. Prompts the user to input today's date in the format DD MM YYYY (20 Jan 2019)
    3. Writes the following summary to task_overview.txt:
    - The total number of tasks.
    - The total number of completed tasks.
    - The total number of uncompleted tasks.
    - The total number of overdue tasks.
    - The Percentage of tasks that are incomplete.
    - The percentage oftasks that are overdue.

    Returns:
    The function returns nothing, but writes the task summary to a file.
    """
    # Fetch all tasks using the 'view_all' function and store them in 'overview_tasks'.
    overview_tasks = view_all()

    # Open a file named 'tasks_overview.txt' in write mode ('w').
    with open("task_overview.txt", "w") as file:

        # Get the total number of tasks by extracting the keys of 'overview_tasks' into task_num_lst.
        task_num_lst = list(overview_tasks.keys())

        # Write the total number of tasks to the file.
        file.write(f"The total number of tasks is: {len(task_num_lst)}\n")

        # Initialize counters for completed, uncompleted, and overdue tasks. 
        complete = 0
        uncomplete = 0
        date_count = 0

        # Prompt the user to input today's date and convert it to a datetime object.
        date_today = input('''Enter today's date in this format: 19 Jan 2024: ''')
        current_date = datetime.strptime(date_today, "%d %b %Y")
        
        # Loop through each task number and its associated info in 'overview_task'.
        for task_num, task_info in overview_tasks.items():

            # Convert the due date of the task into a datetime object.
            due_date = overview_tasks[task_num]["Due date"]
            Date = datetime.strptime(due_date, "%d %b %Y")

            # Check if the task is completed and increment the 'complete' counter.
            if overview_tasks[task_num]["Task complete?"] == "Yes":
                complete += 1

            # Check if the task is uncomplete and increment the 'uncomplete' counter.  
            if overview_tasks[task_num]["Task complete?"] == "No":
                uncomplete += 1

            # Check if the task is overdue (due date is before the current date).
            if Date < current_date:
                if overview_tasks[task_num]["Task complete?"]== "No":
                    date_count += 1

         # Writes the necessary to the file.
        file.write(f"The total number of completed tasks is: {complete}\n")
        file.write(f"The total number of uncompleted tasks is: {uncomplete}\n")
        file.write(f"The total number of tasks that haven't been completed and that are overdue is: {date_count}\n")
        file.write(f"The percentage of tasks that are incomplete is: {round((uncomplete/(complete+uncomplete))*100, 2)}\n")
        file.write(f"The percentage of tasks that are overdue is: {round((date_count/(complete+uncomplete))*100, 2)}\n")

# List of all registered usernames, generated by the usernames() function.
valid_usernames,__ = read_user_file("user.txt")

# Dictionary containing all tasks, generated by the view_all() function.
dict_tasks = view_all()

# Dictionary to store the count of tasks assigned to each user.
users_task_count = {}

# Total number of tasks
total_tasks = len(dict_tasks)

def user_overview():
    """
    This function generates a user overview report from a dictionary of tasks,
    calculating task statistics for each user, and writes the results to a text file.

    The function performs the following:
    - Initializes dictionaries to count total tasks, completed tasks, and incomplete tasks.
    - Prompts user to input the current date in the format 'DD MM YYYY' (10 Jan 2019).
    - Calculates the following statistic metrics:
    The total number of tasks assigned per user
    The perecentage of total tasks assigned to the user.
    The percentage of tasks assigned that have been completed.
    The percentage of tasks still to be completed.
    The perecntage of tasks that are incomplete and overdue. 
    """

    # Initialize dictionaries to keep track of users tasks, overdue, completed and incompleted tasks .
    users_task_count = {}
    completed_task_count = {}
    incomplete_task_count = {}
    overdue_task_count = {}

    # Open the user_overview.txt file to write and save the task statistics
    with open("user_overview.txt", "w") as file:
        # Prompt user for today's date and converts it to a date object.
        date_today = input("Enter today's date in the format DD MM YYYY (e.g 19 Jan 2024): ")
        current_date = datetime.strptime(date_today, "%d %b %Y")

        for task_num, task_info in dict_tasks.items():

            users = task_info["Assigned to"]  # Extracts name of user

            # Check if the task is complete or not
            task_complete = task_info["Task complete?"] == "Yes" 

            # Extracts due date and convert it to a date object.
            task_due_date = task_info["Due date"]
            Due_date = datetime.strptime(task_due_date, "%d %b %Y")  # Extracts due date of tasks

            # Checks if a user is not in the users tasks dictionary, initialize the count to zero
            if users not in users_task_count:
                users_task_count[users] = 0
                completed_task_count[users] = 0
                incomplete_task_count[users] = 0
                overdue_task_count[users] = 0

            # Increments the total task count for each user.
            users_task_count[users] += 1
            
            # If the task is complete, increment the completed task count.
            if task_complete:
                completed_task_count[users] += 1

            else:
                # If the task is incomplete, increment incomplete task count.
                incomplete_task_count[users] += 1

                # If task is incomplete and overdue, increment overdue_task count.
                if Due_date < current_date:
                    overdue_task_count[users] += 1  

        # Loop through task count of each user to generate a report
        for users, count in users_task_count.items():
            total_tasks_assigned = count

            # Calculates percentages for task completion, incompletion, and overdue tasks.
            percentage_assigned = round((total_tasks_assigned/total_tasks)*100, 2)
            percentage_completed = round((completed_task_count[users]/total_tasks_assigned)*100, 2)
            percentage_incomplete = round((incomplete_task_count[users]/total_tasks_assigned)*100, 2)
            percentage_overdue = round((overdue_task_count[users]/total_tasks_assigned)*100, 2)

            # Writes the user's task summary to a file
            file.write(f"{users} has {total_tasks_assigned} tasks assigned\n")
            file.write(f"{users} has {percentage_assigned}% of tasks assigned\n")
            file.write(f"{users} has completed {percentage_completed}% of tasks assigned\n")
            file.write(f"{users} has {percentage_incomplete}% of tasks that must still be completed\n")
            file.write(f"{users} has {percentage_overdue}% of overdue tasks\n")

# Function to display summary statistics
def display_stats():

    '''
    This reads content from tasks_overview.txt and user_overview.txt.
    If the files are not available they are created.

    This function does the following:
    - Attempts to read and dispaly the content of tasks_overview.txt and user_overview.txt files
    - If either file contains content, it prints the details line by line.
    - If the files do not exist or are empty, it notifies the user and prompts them
    to generate a report via the menu
    - In case the files are missing, it creates empty tasks_overview.txt and user_overview.txt files
    '''
    try:
        print()  # Blank space for readability
        with open("task_overview.txt", "r") as file1:
            lines = file1.readlines()
            print("tasks_overview report")
            if lines:  # Checks the file if it has any content
                for line in lines:
                    detail_task_report = line.strip()
                    print(detail_task_report)
            else:
                print("Report not generated yet. Generate report on menu")

        print()  # Blank space for readability

        print("user_overview.txt report:")
        with open("user_overview.txt", "r") as file2:
            lines2 = file2.readlines()
            if lines2:  # Checks if the file has any content
                for line in lines2:
                    detail_user_report = line.strip()
                    print(detail_user_report)

            else:
                print("Report not generated yet. Generate report on menu")

    except FileNotFoundError:
        print("task_overview.txt and user_overview.txt not found.")
        with open("task_overview.txt", "w") as file1:
            file1.write("")

        with open("user_overview.txt", "w") as file2:
            file2.write("")

        print("New files created successfully.")
            
# Create a list of task numbers (key) from the dict_tasks dictionary.
lst_task_num = list(dict_tasks.keys())

# Fetch the latest task information by calling the view_all() function
# and store it in the update_dict_tasks variable.
update_dict_tasks = view_all()

# Function to update tasks.
def update_task_file(updated_dict_tasks):
    '''
    This function writes the updated tasks back to the 'tasks.txt' file
    after tasks are marked or edited.
    Each task is written as a comma-separated line.
    '''
    with open("tasks.txt", "w") as file:
        for task_num, task_info in updated_dict_tasks.items():
            task_line = (
                f"{task_info['Assigned to']}, "
                f"{task_info['Task']}, "
                f"{task_info['Description']}, "
                f"{task_info['Due date']}, "
                f"{task_info['Date assigned']}, "
                f"{task_info['Task complete?']}\n"
            )
            file.write(task_line)

# Function to edit due date or username.
def edit():
    '''
    Allows the user to mark a task as complete or edit the task's assigned user or due date.
    This function performs the following steps:
    1. Prompts the user to enter a task number or return to the main menu by entering -1.
    2. If a valid task number is entered, the user is prompted to either:
    - Mark the task as completed, if it is not already marked as complete.
    - Edit the assigned user or due date, if the task is not yet complete.
    3. The user is allowed up to 3 invalid inputs before the program exits.
    4. If changes are made, the updated tasks are saved to 'tasks.txt'.

    Returns:
    This function updates the task information and writes changes to the file.
    It does not return any values.
    '''
    # Initialize variable to keep track of invalid input.
    max_attempt = 0
    while True:
        # Prompt user to select a task number or return to menu.
        select_or_menu = int(input("Enter a specific task number to edit or -1 to return to menu: "))

        # Exit the function if the user enters -1.
        if select_or_menu == -1:
            print("Returning to menu.")
            return

        # Check if the entered task number is valid.
        if select_or_menu not in lst_task_num:
            print("Invalid task number. Please try again.")
            max_attempt += 1
            if max_attempt == 3:  # Program exits after 3 tries.
                sys.exit("You have reached your maximum number of attempts")
                return
            continue  # Invalid task number, prompt the user again.

        # Prompt user to mark or edit the task.
        mark_or_edit = input("Mark or edit the task? ").lower()

        if mark_or_edit == "mark":
            # Mark the task as complete if it is not already complete.
            if update_dict_tasks[select_or_menu]["Task complete?"] == "No":
                update_dict_tasks[select_or_menu]["Task complete?"] = "Yes"
                print(f"Task {select_or_menu} marked as complete.")
            else:
                max_attempt += 1
                if max_attempt == 3:  # Program exits after 3 tries.
                    sys.exit("You have reached your maximum amounts of tries")
                print(f"Task {select_or_menu} is already complete.")

        elif mark_or_edit == "edit":
            # Edit the task only if it is not marked as complete
            if update_dict_tasks[select_or_menu]["Task complete?"] == "No":
                username_or_due_date = input("Username or due date? ").lower()

                if username_or_due_date == "username":
                    new_user = input("Enter the new username: ")
                    update_dict_tasks[select_or_menu]["Assigned to"] = new_user
                    print(f"Username updated to {new_user} for task {select_or_menu}.")

                elif username_or_due_date == "due date":
                    new_due_date = input("Enter the new due date (format DD MM YYYY - 10 Jan 2020): ")
                    update_dict_tasks[select_or_menu]["Due date"] = new_due_date
                    print(f"Due date updated to {new_due_date} for task {select_or_menu}.")
                else:
                    max_attempt += 1
                    if max_attempt == 3:  # Program exits after 3 tries.
                        sys.exit("You have reached your maximum attempts. Please try again later.")
                    print("Invalid option. Try again.")

            else:
                max_attempt += 1
                if max_attempt == 3:  # Program exits after 3 tries.
                    sys.exit("You have reached your maximum attempts. Please try again later")
                print("Task is already complete and cannot be edited.")

        else:
            max_attempt += 1
            if max_attempt == 3:  # Program exits after 3 tries.
                sys.exit("You have reached your maximum tries. Please try again later.")
            print("Invalid option. Please choose 'mark' or 'edit'.")

        # Write the updated tasks back to the tasks file after changes are made.
        update_task_file(update_dict_tasks)

# Function to display menu options based on user role (admin/non-admin).

def main_menu():
    """
    This is the main logic of the task management system and handles user inputs
    for different actions.

    This function continuously presents with menu options based on their role

    ==Admin Options==
    - r: Register a new user.
    - a: Add a new task.
    - va: View all tasks in the system
    - vm: View tasks assigned to the logged-in user.
    - gr: Generate a report on all tasks.
    - uo: Generate a report on user statistics.
    - ds: Display task and user statistics.
    - e: Exit the system.

    ==Non-admin Options==
    - a: Add a new task.
    - va: View all tasks.
    - vm: View tasks assigned to the logged-in user.
    - e: Exit the system.

    The user is allowed a maximum of 3 invalid input attemts before the system exists.

    Returns:
    The function runs in an infinite loop until the user chooses to exit, and
    does not return any value.

    """
    max_attempt = 0
    # Read valid usernames and passwords from a file.
    valid_usernames, valid_passwords = read_user_file("user.txt")

    # Log the user in and store the logged-in username.
    logged_in_user = login(valid_usernames, valid_passwords)

    # Infinite loop to keep displaying the main menu until the user exits.
    while True:
        # Check if the logged-in user is the admin.
        if logged_in_user == "admin":
            menu_option = input('''
            r - Register a user
            a - Add a task
            va - View all tasks
            vm - View my tasks
            gr - Generate task overview report
            uo - Generate user overview report
            ds - Display statistics
            e - Exit
            ''').lower()

            # If the user selects 'r', register a new user.
            if menu_option == "r":
                register_user()

            # If the user selects 'a', add a new task.
            elif menu_option == "a":
                add_task()

            # If user selects 'va', view all tasks.
            elif menu_option == "va":
                # Retrieve and display all tasks in the system.
                tasks = view_all()
                for task_num, task in tasks.items():
                    print(f"Task {task_num}:")
                    # Loop through the task details and print them.
                    for key, value in task.items():
                        print(f"{key}: {value}")
                    print()

            # If the user selects 'vm', view only tasks assigned to the logged-in user.
            elif menu_option == "vm":
                # Retrieve tasks for the logged-in user.
                tasks = view_mine(logged_in_user)
                for task_num, task in tasks.items():
                    print(f"Task {task_num}:")
                    # Loop through the task details and print them.
                    for key, value in task.items():
                        print(f"{key}: {value}")
                    print()
                edit()

            # If user selects 'gr', generate a task report.
            elif menu_option == "gr":
                task_report()  # Generate the report.
                print("task_overview report successfully generated")

            # If the user selects 'uo', generate a user overview report.
            elif menu_option == "uo":
                user_overview()  # Generate the user overview report.
                print("user_overview.txt report successfully generated")

            # If user selects 'ds', display statistics (both task and user).
            elif menu_option == "ds":
                display_stats()  # Call the function to display system statistics.

            # If the user selects 'e', exit the system.
            elif menu_option == "e":
                sys.exit("Goodbye!!")

            # Handle invalid menu inputs.
            else:
                print("Invalid input. Please try again!")
                # Limit user's incorrect input attempts.
                max_attempt += 1
                if max_attempt == 3:
                    sys.exit("You have reached your maximum tries. Please try again")

        # Menu for non-admin users.
        else:
            menu_option = input('''
            a - Add a task
            va - View all tasks
            vm - View my tasks
            e - Exit
            ''').lower()

            # If the user selects 'a', add a new task.
            if menu_option == "a":
                add_task()

            # If user selects 'va', view all tasks.
            elif menu_option == "va":
                # Retrieve and display all tasks in the system.
                tasks = view_all()
                for task_num, task in tasks.items():
                    print(f"Task {task_num}:")
                    # Loop through the task details and print them.
                    for key, value in task.items():
                        print(f"{key}: {value}")
                    print()

            # If the user selects 'vm', view only tasks assigned to the logged-in user.
            elif menu_option == "vm":
                # Retrieve tasks for the logged-in user.
                tasks = view_mine(logged_in_user)
                if tasks:
                    for task_num, task in tasks.items():
                        print(f"Task {task_num}:")
                        # Loop through the task details and print them.
                        for key, value in task.items():
                            print(f"{key}: {value}")
                        print()
                    edit()
                else:
                    print("No tasks for this username")

            # If the user selects 'e', exit the system.
            elif menu_option == "e":
                sys.exit("Goodbye!!")

            # Handle invalid menu inputs.
            else:
                print("Invalid input. Please try again!")
                # Limit user's incorrect input attempts.
                max_attempt += 1
                if max_attempt == 3:
                    sys.exit("You have reached your maximum tries. Please try again")

# Calls the main_menu function.
main_menu()
